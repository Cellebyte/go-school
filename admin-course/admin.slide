# Golang Admin Workshop
Learn how to use Golang for tooling
Tags: go, teaching
Summary: German Golang workshop slides.

Matthias Bruns
Freelancer
info@matthiasbruns.com
https://github.com/matthiasbruns
https://www.linkedin.com/in/matthiasbruns/

## Basic Course 1st day

## Chapter 1 - Exec on OS

## os package

* https://pkg.go.dev/os
* **`os`** package provides platform-independent interface to operating system functionality

.code examples/01_os/cmd/intro/main.go /^//START_1/,/^//END_1/ HL1


## os/exec package

* https://pkg.go.dev/os/exec
* **`os/exec`** allows to call scripts and other binaries directly - this may break the platform-independency

.code examples/01_os/exec.go HL1

## Example - Call "ls"

* Calls `ls -lts` 
* Does not work on Windows 

.play examples/01_os/cmd/ls/main.go /^//START_1/,/^//END_1/ HL1

## Exercise - Build a platform-independ ls 

* Do not use **`os/exec`**
  * Use File.Readdir https://pkg.go.dev/os#File.Readdir
* Log the names of the files containing a folder
* _(optional)_ add the path to the folder via an argument
* _(optional)_ get information like permission with **`os.Stat(file)`**

## Result - platform-independ ls 

TODO code exercie

*show in IDE*

## Chapter 2 - HTTP

## HTTP Server

* Spins up a http server with two routes
  * http://localhost:8090/hello
  * http://localhost:8090/headers
* Allows all methods: GET, POST, ....

.play examples/02_http/cmd/intro/main.go /^//START_1/,/^//END_1/ HL1

## HTTP Server II

* http.ListenAndServe(":8090", nil) - why is the handler set to **`nil`**?
  * "The handler is usually nil, which means to use DefaultServeMux"
* What is a ServeMux?
  * ServeMux is an HTTP request multiplexer
  * Matches an incomming request against the configured patterns and calls the one that most closely matches the url
  * There are many other ServerMux implementations in the standard lib

## HTTP Client

* Issue an HTTP GET request to a server. 
* **`http.Get`** is a quick way to create an http.Client - uses http.DefaultClient
* Uses `bufio` to read the response data
  * Package bufio implements buffered I/O

.play examples/02_http/cmd/client/main.go /^//START_1/,/^//END_1/ HL1

## http package

* Enfore a certain http method by checking the incoming request

.code examples/02_http/method.go HL1

* If you need custom headers for http.Client, instantiate your own 

.code examples/02_http/client.go HL1

## Basic Auth

* Blocks public access from the web resource
* Can be read via **`request.BasicAuth()`**
* If the auth header is not a Basic Auth header,  **`ok`** will be **`false`**
* You have to validate username & password by yourself

.code examples/02_http/basic_auth.go HL1

## JWT Auth

* JWT stands for JSON Web Token
* JWT example **`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ.2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54`**
* The first part is the header **`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`**
  * specifies information like the algorithm used to generate the signature
* The second part is the payload **`eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ`**
  * contains application specific information
  * information about the expiry and validity of the token
* The third part is the signature **`2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54`**
  * generated by combining and hashing the first two parts along with a secret key
* header and payload are not encrypted

## JWT creation algorithm

* Encode Header and Payload with BASE64
* Concat results and encrypt with secret key = signature

.image examples/02_http/jwt.svg

## JWT validation algorithm

* Validating the JWT on server side can be done in two ways
* Validate **contents** synchronously by recalculating the signature based on the incoming header and payload
  * If calculated signature matched the incoming one, you can be sure, that the payload was not changed
  * If the signature differes the payload was modified
* Validate **authenticity** of the signature by verifying with a corresponding public key
  * Works for keys signed with e.g. RS256 alg

## Using golang-jwt

* We could implement JWT handling manually
* Go allows us to easily reuse open source projects hosted on GitHub.com
* To do so, we need to use Go Modules **`go.mod`**

.code examples/02_http/gomod.go

## Example - Creating tokens

* Creates a token signed with **`SigningMethodHS256`**
* Uses **`customClaims`** with **`json`** representation of values

.code examples/02_http/jwt.go /^//START_1/,/^//END_1/ HL1

## Example - Validating tokens

* Parse with the parsing settings for the selected algorithm
* Verify that the alg is actually one that we expect
* Map the claims just for printing

.code examples/02_http/jwt.go /^//START_2/,/^//END_2/ HL2

## Exercise - Create own auth server

* Create a new project folder and create a new project with 
> **`go mod init PROJECT_NAME`** 
* Add **`github.com/golang-jwt/jwt/v4`** to you go project with 
> **`go get github.com/golang-jwt/jwt/v4`**
* Start by adding simple endpoints to check that your http server is working correctly
* Add two endpoints, one to login and one for protected content
  * **`login`** should generate a jwt token
  * **`protected`** should validate the token and check for a claim "admin" that must be set  

## Result - Create own auth server

*show in IDE*

## Chapter 3 - Parsing

## JSON parsing

* **`encoding/json`** provides functionality for json handling
* you can parse raw json, files, requests or other streams

.code examples/03_json/raw.go HL1

## YAML parsing
details

## Chapter 4 - SQL

## database/sql package
details

## Example MySQL
details

## Connection Pools
details

## Queries
details

## Transactions
details

## Chapter 5 - Testing

## Built-In Testing
details

## 3rd Party Libraries
details

## Chapter 6 - CLI reloaded

## vanilla cli
details

## libraries to use
details

## Chapter 7 - Go vs Python

## When to use Golang

https://dzone.com/articles/golang-vs-python-which-one-to-choose
* Go Performance

## When to use Python
details

## Chapter 8 - Question from day 1

## Chapter 9 - Q&A